#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/select.h>

#include <signal.h>
#include <sys/errno.h>

void die(char *message);

int main(int argc, char *argv[])
{
	char *_taskArguments[4]; 		// array of 4 pointers to char
	pid_t _taskPID;
	int _taskStatus;
	
	// _taskArguments is getting filled up

	_taskArguments[0] = "./Task"; 	// sample data - the task executable
	_taskArguments[1] = "2"; 		// sample data - the number of the task to be performed
	_taskArguments[2] = "A"; 		// sample data - the argument of the task
	_taskArguments[3] = NULL; 		// sample data - terminating NULL
	
	// something else is going on
	
	if ((_taskPID = fork()) == 0)					// = TRUE if this the child process
	{
		alarm(10);									// set timeout to 10 seconds
		execv(_taskArguments[0], _taskArguments);	// the task is executed
	}
	else if (_taskPID < 0)							// = TRUE if something went wrong while creating a child process
		die("Forking failed; _taskPID = %d", _taskPID);
	
	wait(&_taskStatus);								// waiting for the task to finish
	
	if (!WIFEXITED(_taskStatus))					// = TRUE if the task was terminated by the alarm
		die("Task timed out");
	
	if (WEXITSTATUS(_taskStatus))					// = TRUE if the task exit code isn't equal to 0
		die("Task failed; WEXITSTATUS(_taskStatus) = ", WEXITSTATUS(_taskStatus));
		
	
		


	//pid_t _task;
	
	

	/*FILE* tmpTask;
	char tmpString[1024];
	int tmpPID;

	strcpy(tmpString, "./Task ");
	strcat(tmpString, argv[1]);
	strcat(tmpString, " ");
	strcat(tmpString, argv[2]);

	printf("test1\n");
	tmpTask = popen(tmpString, "r");
	printf("test2\n");
	
	if (tmpTask == NULL)
		die("Error: Something wrong with the task executable");
		
	fscanf(tmpTask, "%d", &tmpPID);
	printf("%d\n", tmpPID);
	
	
	
	int tmpKill = kill(tmpPID, SIGKILL);

	if(tmpKill == ESRCH)
		printf("A\n");
	else if (tmpKill == EPERM)
		printf("B\n");
	else
		printf("C\n");

	
	
	
	printf("%d\n", pclose(tmpTask));*/
		
	/*fd_set set;
	struct timeval timeout;
	int rv;
	char buff[100];
	int len = 100;

	FD_ZERO(&set);
	FD_SET(tmpTask, &set);

	timeout.tv_sec = 10;
	timeout.tv_usec = 0;

	rv = select(tmpTask + 1, &set, NULL, NULL, &timeout);
	
	if(rv == -1)
		perror("select");
	else if(rv == 0)
		printf("timeout");
	else
		read( filedesc, buff, len );
		
		
		

	fgets(tmpString, sizeof(tmpString), tmpTask);
	
	if (pclose(tmpTask) == 0)
		printf("%s\n", tmpString);
	else
		die("Error: Task crashed");*/
	
	exit(0);
}
